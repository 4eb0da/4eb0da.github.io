---
title: "Нужен ли float в 2026м году?"
description: "Совершим археологические раскопки и вспомним, что такое 'вёрстка флоатами', посмотрим на её проблемы и проверим, как ведёт себя float в современном CSS"
date: 2026-02-15
tags:
    - css
---

<script lang="ts">
    import Float from './Float.svelte';
    import MultipleFloats from './MultipleFloats.svelte';
    import MultipleFloats2 from './MultipleFloats2.svelte';
    import Clearfix from './Clearfix.svelte';
    import Clearfix2 from './Clearfix2.svelte';
    import ChaosFloat from './ChaosFloat.svelte';
    import RTLFloat from './RTLFloat.svelte';
    import ShapeOutside from './ShapeOutside.svelte';
    import Sticky from './Sticky.svelte';
    import Columns from './Columns.svelte';
    import Anchor from './Anchor.svelte';
</script>

## Вступление

Достаточно давно вёрстка "флоатами" была модным способом сделать рядовые вещи. Конечно, это был своего рода хак, и с тех пор в браузерах появилось много способов сделать тоже самое, более прямолинейно и без болезненных спецэффектов.

Вспомним, зачем флоаты были придуманы изначально, что делали на пике их использования, и попробуем понять их место в 2026м году.

## Первоначальное назначение

Интернет начинался с достаточно простого контента: текстовые статьи, ссылки, заголовки. Через какое-то время появились картинки.

В обычных книгах иллюстрации часто размещаются сбоку от текста. Думаю, именно из них черпали вдохновение авторы `float`:

<Float />

У `float` два основных значения: `left` и `right`. Текст (и другие инлайновые элементы) будут обтекать элементы с `float`, а сами "плавающие" элементы выпадают из блочной модели.

## Вёрстка "флоатами"

Что будет, если расположить несколько элементов "слева" или "справа" подряд? Они будут вставать друг за другом:

<MultipleFloats />

Во времена, когда не было флексбоксов, гридов, да и что там, когда даже полноценно `display: inline-block` использовать было нельзя, флоаты позволяли расположить элементы горизонтально. Вторым популярным способом в те времена были таблицы, однако флоаты могли сделать перенос, похожий на `flex-wrap`:

<MultipleFloats2 />

## Проблемы

Вёрстка флоатами были "костылём", так как такого использования не предполагалось изначально. Подход приводил к проблемам, с которыми научились жить.

### clearfix

Как уже говорилось выше, флоаты "вытаскивают" элемент из обычного потока. Более того, это приводит к тому, что элементы могут вываливаться за пределы родительского блока:

<Clearfix />

Для решения этой проблема чаще всего использовался подход, который назывался `clearfix`. Благодаря свойству `clear` можно было заставить обычный элемент гарантированно занять позицию после "плавающего". Если расположить такой элемент после всех флоатов, то это позволит "растянуть" родительский элемент, чтобы ничего не вываливалось:

```css
.clearfix {
    clear: both;
}
```

<Clearfix2 />

### Странная логика переносов

Перенос флоатов работал совсем не так, как работает перенос во флексбоксах. По сути, "плавающий" блок пытался найти место по верхней линии контента родительского блока. Если же места по горизонтали не хватало, то по нижней границе предыдущего флоата. Это могло порождать весьма любопытные (и неожиданные) лейауты:

<ChaosFloat />

## Модернизация флоатов

Флоаты появились очень давно, и за прошедшее время нашлось несколько улучшений, которые были применены к первоначальной идее.

### Логические значения

Видя `float: left` / `right`, встаёт вопрос про RTL (right-to-left). Ведь если мы хотим сделать выравнивание картинки по началу текста, то значение нужно будет менять в зависимости от направления текста.

К счастью, эта проблема была решена в виде значений `float: inline-start` / `inline-end`:

```css
img {
    float: inline-start;
}
```

<RTLFloat />

### Произвольные формы для обтекания текста

Свойство `shape-outside` развивает идею обтекания текстом какой-либо фигуры:

```css
img {
    float: left;
    shape-outside: circle(50%);
}
```

<ShapeOutside />

Можно использовать готовые примитивы, произвольные полигоны и даже внешние изображения.

## float в современном CSS

Давайте выйдем за пределы `float` и посмотрим, что будет при взаимодействии с другими раскладками.

1) `position`.

При использовании `position: absolute` float отключается, тут ничего интересного.

С `position: relative` всё работает, и таким образом можно подвинуть плавающий элемент в сторону. Инлайновые элементы продолжают "обтекать" старое положение элемента, без учёта `position: relative`.

`position: sticky` тоже работает. Если элемент смещается правилом `position: sticky`, то обтекающие элементы продолжают обтекать его старую позицию. Тем самым не получится сделать "расталкивание" элементов по мере скролла.

<Sticky />

2) `display: flex` / `grid`

Если родительский элемент float – `flex` или `grid`, то `float` просто не работает.

3) `columns`

Многоколоночная раскладка работает как раз с текстом, поэтому не удивительно, что `float` работает в ней. Из интересного можно отметить, что элементы с `float` могут быть "разрезаны" и расположены между несколькими колонками:

<Columns />

4) `anchor-positioning`

Флоаты дружат с `anchor-positioning` и, к примеру, можно сделать тултип к "плавающему элементу":

<Anchor />

## Итого

Флоаты сегодня – редкий зверь на просторах HTML-лесов. И мне кажется, вполне заслуженно. Он всё ещё полезен для случаев, когда нам нужно получить обтекание текстом какой-либо фигуры. Однако за пределами этого специфичная логика раскладки флоатов с трудом находит применение. Пик популярности `float` прошёл, и на замену ему пришли другие раскладки, которые лучше справляются с обязанностями, которые были взвалены в своё время на `float`.

