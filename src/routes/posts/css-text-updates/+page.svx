---
title: "Отрисовка текста и её обновки в браузерах"
description: "Целая прорва новых возможностей по отрисовке текста в браузерах. Посмотрим, что нового и на чём сейчас сконцентрированы браузеры"
date: 2026-02-22
tags:
    - css
---

<script lang="ts">
    import BrowserCompatData from '$lib/components/BrowserCompatData.svelte';
    import TextJustify from './TextJustify.svelte';
    import TextIndent from './TextIndent.svelte';
    import HangingPunctuation from './HangingPunctuation.svelte';
    import LetterSpacing from './LetterSpacing.svelte';
    import SpellingError from './SpellingError.svelte';
    import TextDecorationInset from './TextDecorationInset.svelte';
    import VariantEmoji from './VariantEmoji.svelte';
    import Hyphens from './Hyphens.svelte';
    import FitWidth from './FitWidth.svelte';
    import Chat from './Chat.svelte';
</script>

## Вступление

Браузеры активно внедряют целую пачку новых возможностей по отрисовке текста. Если раньше мы могли порадоваться кастомным шрифтам, и это уже было выше мечтаний ряда разработчиков, то сейчас свойства для кастомизации отрисовки текста исчисляются десятками.

Давайте посмотрим, что нового происходило за последнее время, над чем работают браузеры и чего нам (оказывается) не хватало все эти годы.

## Обновления @font-face

`@font-face` позволяет определять кастомные шрифты. Дескрипторы внутри него (не свойства!) позволяют настраивать этот шрифт. И если раньше мы настраивали доступные значения по типу `font-weight`, то теперь потихоньку начинаем настраивать "предустановки". CSS свойства протекают в `@font-face`.

Это полезно, так как определённые настройки мы можем применить именно к кастомному шрифту, а обычные свойства работают на все шрифты сразу.

В частности, за недавнее время в Хроме появились дескрипторы `font-feature-settings` и `font-variation-settings`:

```css
@font-face {
    font-family: 'Sample';
    src: ...;
    font-feature-settings: 'tnum';
    font-variation-settings: 'wdth' 150;
}
```

<BrowserCompatData
    id="css.at-rules.font-face.font-feature-settings"
    title="@font-face font-feature-settings descriptor"
/>

`font-feature-settings` позволяет настраивать фичи OpenType, такие, как лигатуры, варианты отрисовки цифр, использование определённого стиля символов и многое другое.

<BrowserCompatData
    id="css.at-rules.font-face.font-variation-settings"
    title="@font-face font-variation-settings descriptor"
/>

`font-variation-settings` позволяет настраивать определённые вариационные оси шрифта, например, ширину (возможности сильно разнятся от конкретных шрифтов).

<BrowserCompatData
    id="css.at-rules.font-face.size-adjust"
    title="@font-face size-adjust descriptor"
/>

Помимо перечисленного, не так давно реализовали дескриптор `size-adjust`, который работает аналогично свойству `font-size-adjust`. Они позволяют настраивать метрики шрифта, чтобы можно было выровнять разные шрифты между собой. Это бывает полезно, если шрифт может меняться на глазах у пользователя во время загрузки, либо если несколько шрифтов сопутствуют рядом друг с другом.

## Масштабирование шрифтов

Говоря про изменения размеров шрифтов, стоит упомянуть и про системные настройки размера текста.

<BrowserCompatData
    title="meta text-scale"
    compat={{
        support: {
            chrome: {
                version_added: 146
            }
        }
    }}
    link="https://chromestatus.com/feature/5112244702674944?gate=6229572190339072"
/>

Новый мета-тег из Хрома 146 (выходит на днях) `text-scale` позволяет сказать браузеру, что страница учитывает пользовательские настройки размера текста:

```html
<meta name="text-scale" content="scale">
```

Используя данный мета-тег, вы говорите браузеру, что уже учитываете пользовательские настройки по масштабированию шрифтов, и что браузеру не нужно использовать свои механизмы.

<BrowserCompatData
    title="env(preferred-text-scale)"
    compat={{
        support: {
            chrome: {
                version_added: 138
            }
        }
    }}
    link="https://developer.mozilla.org/en-US/docs/Web/CSS/Guides/Environment_variables/Using#preferred-text-scale"
/>

Для этой же цели служит и новое значение `env(preferred-text-scale)`, которое как раз и будет возвращать значение масштабирования, избранное пользователем. Однако в большинстве случаев оно не нужно – достаточно правильно объявить размер шрифта на `<html>` и реагировать на него в странице (например, через `rem`).

## Балансировка длины строк

<BrowserCompatData
    id="css.properties.text-wrap.balance"
    title="text-wrap: balance"
/>
<BrowserCompatData
    id="css.properties.text-wrap.pretty"
    title="text-wrap: pretty"
/>

Свойство `text-wrap: balance` – не новое, а вот значение `pretty` появилось чуть позже. Учитывайте это при написании стилей! `pretty` сейчас поддерживается в Safari 26, но не поддерживается в Файерфоксе, поэтому имеет смысл писать значение с фолбеком в `balance`.

## Выравнивание текста

Говоря про балансировку длины строк, нельзя не вспомнить и про свойства для выравнивания слов вдоль строки.

<BrowserCompatData
    id="css.properties.text-justify"
    title="text-justify"
/>

Свойство `text-justify` появилось относительно давно в Файерфоксе, однако в Хроме существует только со 145й версии. Оно позволяет включить конкретный режим распределения свободного места с `text-align: justify` (да, оказывается, вариантов несколько). В частности, можно включить вариант с отступами *между буквами* (не работает в Сафари):

<TextJustify />

<BrowserCompatData
    id="css.properties.text-align.match-parent"
    title="text-align: match-parent"
    link="https://developer.mozilla.org/ru/docs/Web/CSS/Reference/Properties/text-align#match-parent"
/>

Обновление ожидает и само свойство `text-align`. Уже давно значение `match-parent` было реализовано, однако и по сей день в Хромиумах используется вариант с префиксом. Подозреваю, что в будущем нас ждёт беспрефиксный вариант везде.

## Кастомная обрезка текста многоточием

<BrowserCompatData
    id="css.properties.text-overflow.string"
    title="text-overflow: <string>"
    link="https://developer.mozilla.org/en-US/docs/Web/CSS/Reference/Properties/text-overflow#string"
/>

Говоря про старые свойства, которые давно реализованы в Файерфоксе и которые застряли во времени, можно вспомнить и про `text-overflow: '<строка>'`. Значение позволяет задать произвольную строку вместо стандартного троеточия, и входит в обновлённую спеку CSS Overflow Module Level 4.

## Дополнительные настройки красной строки

<BrowserCompatData
    id="css.properties.text-indent.each-line"
    title="text-indent: each-line"
    link="https://developer.mozilla.org/ru/docs/Web/CSS/Reference/Properties/text-indent#each-line"
/>
<BrowserCompatData
    id="css.properties.text-indent.hanging"
    title="text-indent: hanging"
    link="https://developer.mozilla.org/ru/docs/Web/CSS/Reference/Properties/text-indent#hanging"
/>

Обычно отступ первой строки в абзаце (красная строка) используется в вебе не часто, а тут подвезли дополнительную кастомизацию для него (и теперь она доступна во всех браузерах):

```css
.p1 {
    text-indent: 3em each-line;
}
.p2 {
    text-indent: 3em hanging;
}
```

Значение `each-line` позволяет задать отступ не только для начала абзаца, но и для каждой строки (не визуальной, а в терминах явного переноса в тексте). Значение `hanging` позволяет настраивать отступ не для первой строки абзаца, а для всех остальных. Более того, оба новых значения можно комбинировать:

```css
.p3 {
    text-indent: 3em hanging each-line;
}
```

<TextIndent />

Не уверен, как часто эти значения будут использоваться, но в прошлом я видел изобретательные варианты использования `text-indent`.

## Висящая пунктуация

<BrowserCompatData
    id="css.properties.hanging-punctuation"
    title="hanging-punctuation"
/>

Ещё одно свойство с `hanging`, но теперь уже в названии, а не в значении – `hanging-punctuation`. Свойство позволяет вынести символы пунктуации за пределы лайнбокса. Это может быть полезно, например, для стилизации цитат:

<HangingPunctuation />

Свойство есть в спеке CSS Text Module Level 3, которая в статусе "кандидат к рекомендации", однако реализовано только в Сафари, и уже достаточно давно. Возможно, текущая активность – признак того, что браузеры хотят вернуться к свойству?

## letter-spacing и word-spacing в процентах

Представьте ситуацию: вы хотите сделать отступ между букв для всех элементов, и чтобы этот отступ зависел от размера шрифта. Вполне представимая задача, и сперва она звучит, как очень простая. В CSS есть наследование, остаётся один раз написать нужное свойство. Фиксированные значения не подходят, но у нас ведь есть единицы измерения, зависящие от размера текста. Ни слова больше:

```css
html {
    letter-spacing: .1em;
}
```

И... Это работает не так, как нам бы хотелось для решения такой задачи. Итоговое значение будет сначала вычислено, а потом отнаследовано! Итого получим просто фиксированное значение.

Проблему решают процентные значения, которые, как ни странно, будут отнаследованы, и только затем вычислены на элементе:

<LetterSpacing />

Этот код наконец-то работает во всех браузерах, и Хром догнал остальных в 145й версии. Аналогичная история произошла и с `word-spacing`.

## Подчёркивания и прочие text-decoration

Иногда люди делают собственные поля ввода, а с ними встаёт задача и подсветки грамматических и прочих ошибок. Вопрос особенно интересен в связи с внедрением `Highlight API`. И долгое время реализовать волнистое красное подчёркивание было можно, но это было неприятно и бажно.

<BrowserCompatData
    id="css.properties.text-decoration.spelling-error"
    title="text-decoration: spelling-error"
    link="https://developer.mozilla.org/en-US/docs/Web/CSS/Reference/Properties/text-decoration"
/>
<BrowserCompatData
    id="css.properties.text-decoration.grammar-error"
    title="text-decoration: grammar-error"
    link="https://developer.mozilla.org/en-US/docs/Web/CSS/Reference/Properties/text-decoration"
/>

С выходом Сафари 26.2 мы наконец-то можем использовать значения `spelling-error` / `grammar-error` для ошибок во всех браузерах:

<SpellingError />

<BrowserCompatData
    id="css.properties.text-decoration-inset"
    title="text-decoration-inset"
/>

В Файерфоксе 146 реализовали другой интересный вариант настройки подчёркивания: `text-decoration-inset`. Свойство позволяет сместить начало и/или конец подчёркивания. Мне видится, что с помощью этого свойства можно будет получить какие-то интересные декоративные решения. Также можно подумать и про эффекты с ховером или просто анимированное выделение текста:

<TextDecorationInset />

## Математический шрифт

<BrowserCompatData
    id="css.properties.font-family.math"
    title="font-family: math"
    link="https://developer.mozilla.org/en-US/docs/Web/CSS/Reference/Properties/font-family#math"
/>

Долгое время в браузерах были встроенные "семейства шрифтов", по типу всем известных `serif` / `monospace` / `sans-serif` и некоторых других. Новое значение в списке – "математический" шрифт.

Шрифт в первую очередь нужен для использования в `MathML`.

## Переопределение языковых настроек шрифта

<BrowserCompatData
    id="css.properties.font-language-override"
    title="font-language-override"
/>

В шрифтах есть глифы, специфичные для конкретных языков. Обычно браузеры используют атрибут `lang` в HTML для определения языка, и задействуют эти специальные глифы. Однако со свойством `font-language-override` можно разделить эти настройки: `lang` оставить для реального значения языка, а CSS свойством `font-language-override` поменять визуальное представление.

Это может быть использовано для глифов, которые есть в шрифте для одного языка, и нет для другого. Возможно, задача не очень характерная для русскоязычных сайтов, и вообще похоже на очень точную настройку, но всё равно звучит очень интересно) Лишь бы нужный шрифт нашёлся.

Ах да, Хром догоняет Файерфокс, а Сафари всё ещё ждём.

## Варианты отображения эмодзи

Эмодзи – вполне валидная часть юникода, и встречаются на сайтах. Браузеры сделали доработки и тут.

В 145м Хроме в режиме высокой контрастности теперь используются чёрно-белый вариант эмодзи, что вполне логично.

Также появился способ выбирать вариант отображения эмодзи с помощью свойства `font-variant-emoji`. Такого же эффекта можно было достичь с помощью управляющих последовательностей юникода, а теперь всё проще.

<BrowserCompatData
    id="css.properties.font-variant-emoji"
    title="font-variant-emoji"
/>

<VariantEmoji />

## Настройки переноса текста

<BrowserCompatData
    id="css.properties.hyphenate-limit-chars"
    title="hyphenate-limit-chars"
/>

Несмотря на давнюю реализацию переносов слов в браузерах, использований этой возможности не так много. И дело тут во всевозможных нюансах, начиная от того, что для реализации требуются наличие словарей для конкретного языка на устройстве. Дело было ещё и в том, что текст с переносами получался не очень красивым. Для решения этой задачи сделали новое свойство `hyphenate-limit-chars`, которое доступно с Хрома 109 и с Файерфокса 137.

<Hyphens />

Получается, ждём Сафари? Хотя Сафари идёт своим путём и вкладывает силы в красоту текста в `text-wrap: pretty`.

## Отображение иероглифов и арабской вязи

Немного затронем языки, которые редко встречаются на русскоязычных сайтах.

В Сафари 26.2 реализовали слитную отрисовку символов, которые расположены в разных DOM-элементах. Это особенно характерно для арабской вязи, когда символы рисуются не отдельно, а объединяются вместе друг с другом.

Китайский, корейский, японский языки также регулярно получают обновления от браузеров. Новые значения для `text-transform`, `text-decoration-skip-ink`, новые свойства `text-autospace`, `ruby-align`, `ruby-overhang`, `text-spacing-trim` появились в браузерах и я не буду подробно на этом останавливаться.

## Что не появилось в браузерах

Несмотря на обширнейший список нововведений, несколько очень ожидаемых вещей в браузерах так и не появилось.

### line-clamp без префиксов

<BrowserCompatData
    id="css.properties.line-clamp"
    title="line-clamp"
/>

Свойство `-webkit-line-clamp` с нами уже очень давно и так часто используется, что его поддержали во всех актуальных браузерах вместе с префиксом `-webkit`. Некоторое время назад была попытка сделать беспрефиксный вариант свойства, да ещё и с интересным значением `auto`, но ни один браузер так и не реализовал его.

Хочется верить, что в какой-то момент свойство доделают, а пока что продолжаем ждать и использовать `-webkit-line-clamp`.

### Размер текста по ширине контейнера

Старая задача с отображением текста под размер контейнера решается годами, если не десятилетиями.

Есть прототип свойства `text-grow`, который даже был реализован одним из разработчиков на базе Хрома 145, и есть объяснение этого свойства в виде доки. Ждём свойство в скором будущем?

<FitWidth />

### Уменьшение ширины контейнера под многострочный текст

Ещё одна очень старая задача. В случае, если текст многострочный, он всё равно займёт всю доступную ширину, даже если место будет не нужно. Минимальная ширина вычисляется по ширине максимального слова. Максимальная – по ширине текста в одну строку. Итого у нас нет "реальной" ширины многострочного текста. Особенно ярко проблему видно в вёрстке всевозможных чатов, которые так часто встречаются в последнее время:

<Chat />

Ходили слухи о том, что есть желание реализовать такую возможность в браузерах, но последнее время я ничего про это не слышал. Возможно, пропустил? Напишите в комментариях, пожалуйста.

## Подведём итоги

Мне страшно. Все эти обновки проходили где-то рядом со мной, и когда я думал о написании статьи, ожидал, что их в 2-3 раза меньше. С одной стороны, нерешённых задач с текстом всё ещё хватает, с другой – настроек уже столько, что я сомневаюсь, что есть хоть один человек, который знает про все из них.

Приятно, что у нас появляется всё больше возможностей для более тонкой настройки отображения текста, ведь текст – один из основных видов контента на сайтах, за которым приходят пользователи. Мы смотрим на него ежедневно, и хочется, чтобы он выглядел идеально в целой куче условий.

Будут ли пользоваться этими свойствами разработчики или просто банально не знать об их существовании, потому что их слишком много? Вот как раз эту проблему и пытается решить статья)
